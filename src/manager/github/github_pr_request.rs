//! Defines a struct for handling requests from github to start two runs of the same test on the
//! base and head commits for a PR

use crate::manager::github::{util, Error};
use crate::manager::notification_handler::NotificationHandler;
use crate::manager::test_runner::TestRunner;
use crate::models::run_group::RunGroupData;
use crate::models::run_group_is_from_github::{NewRunGroupIsFromGithub, RunGroupIsFromGithubData};
use crate::models::test::TestData;
use diesel::PgConnection;
use log::{debug, error};
use serde::Deserialize;
use serde_json::Value;
use uuid::Uuid;
use crate::models::run_in_group::RunInGroupData;

/// Represents the data received from a GitHub Actions request to start two runs of the same test on
/// separate branches (the PR use case)
///
/// `test_input_key` and `eval_input_key` each respectively refer to the key in the test_input and
/// eval_input for the test that should be filled with a build generated by CARROT using the
/// specified `software_name` and commits.  `author` refers to the Github username of the person
/// who triggered the request in GitHub by creating a comment in the format to trigger a test run
#[derive(Debug, Deserialize, Eq, PartialEq)]
pub struct GithubPrRequest {
    pub test_name: String,
    pub test_input_key: Option<String>,
    pub eval_input_key: Option<String>,
    pub software_name: String,
    pub head_commit: String,
    pub base_commit: String,
    pub owner: String,
    pub repo: String,
    pub issue_number: i32,
    pub author: String,
}

impl GithubPrRequest {
    /// Attempts to create a GithubRunRequest from `obj` by deserializing and updates input keys to
    /// be None if they have been provided as empty strings
    pub fn from_json(obj: &Value) -> Result<Self, serde_json::Error> {
        // Parse as a GithubRunRequest
        let mut request: GithubPrRequest = serde_json::from_value(obj.clone())?;
        // If either of the input keys for docker images is an empty string, set it to null
        match &request.test_input_key {
            Some(key) => {
                if key.is_empty() {
                    request.test_input_key = None;
                }
            }
            None => {}
        }
        match &request.eval_input_key {
            Some(key) => {
                if key.is_empty() {
                    request.eval_input_key = None;
                }
            }
            None => {}
        }

        Ok(request)
    }

    /// Creates a record in the RUN_GROUP_IS_FROM_GITHUB table to store the data (`owner`, `repo`,
    /// `issue_number`, `author`) related to the github comment that triggered the run_group
    /// (`run_group_id`)
    fn record_github_info(
        &self,
        conn: &PgConnection,
        run_group_id: Uuid,
    ) -> Result<RunGroupIsFromGithubData, diesel::result::Error> {
        let github_info_rec = NewRunGroupIsFromGithub {
            run_group_id,
            owner: self.owner.clone(),
            repo: self.repo.clone(),
            issue_number: self.issue_number,
            author: self.author.clone(),
            base_commit: self.base_commit.clone(),
            head_commit: self.head_commit.clone(),
            test_input_key: self.test_input_key.clone(),
            eval_input_key: self.eval_input_key.clone(),
        };

        RunGroupIsFromGithubData::create(conn, github_info_rec)
    }

    /// Sends failure notifications for failure to start PR runs for test with `test_id`, and
    /// deletes run_group indicated by `empty_run_group_id`
    async fn handle_run_start_failure(
        &self,
        notification_handler: &NotificationHandler,
        conn: &PgConnection,
        test_id: Option<Uuid>,
        empty_run_group_id: Option<Uuid>,
        error_message: &str,
    ) {
        error!(
            "Encountered an error when trying to start a run from GitHub: {}",
            error_message
        );
        // Send notifications for failure
        if let Err(e) = notification_handler
            .send_pr_run_failed_to_start_from_github_notifications(
                conn,
                &self.owner,
                &self.repo,
                &self.author,
                self.issue_number,
                &self.test_name,
                test_id,
                error_message,
            )
            .await
        {
            error!(
                "Failed to send run start failure notifications due to the following error: {}",
                e
            );
        }
        // Delete the run group, if id is provided
        if let Some(run_group_id) = empty_run_group_id {
            if let Err(e) = RunInGroupData::delete_by_run_group_id(conn, run_group_id) {
                error!("Failed to delete run_group mappings for run_group {} left over after failure to start PR run: {}", run_group_id, e);
            }
            if let Err(e) = RunGroupData::delete(conn, run_group_id) {
                error!("Failed to delete empty run_group {} left over after failure to start PR run: {}", run_group_id, e);
            }
        }
    }

    /// Starts two runs (using `test_runner`), one using the `self.base_commit` and one using
    /// `self.head_commit`, with run_group that both belong to.  Then sends notifications to
    /// indicate the runs have started successfully, or containing error messages if anything goes
    /// wrong
    pub async fn process(
        &self,
        test_runner: &TestRunner,
        notification_handler: &NotificationHandler,
        conn: &PgConnection,
    ) {
        // First, retrieve the test id for the test name
        let test_id = match TestData::find_id_by_name(conn, &self.test_name) {
            Ok(id) => id,
            Err(e) => {
                let error_message = format!("Failed to start PR runs from GitHub with test_name: {} due to error when trying to retrieve test_id: {}", self.test_name, e);
                self.handle_run_start_failure(
                    notification_handler,
                    conn,
                    None,
                    None,
                    &error_message,
                )
                .await;
                return;
            }
        };
        // Create a run_group for these runs
        let run_group = match RunGroupData::create(conn) {
            Ok(run_group) => run_group,
            Err(e) => {
                self.handle_run_start_failure(
                    notification_handler,
                    conn,
                    Some(test_id),
                    None,
                    &Error::DB(e).to_string(),
                )
                .await;
                return;
            }
        };
        // Start run for head
        let head_run = match util::start_run_from_request(
            conn,
            test_runner,
            test_id,
            Some(run_group.run_group_id),
            self.test_input_key.as_deref(),
            self.eval_input_key.as_deref(),
            &self.software_name,
            &self.head_commit,
        )
        .await
        {
            Ok(run) => run,
            Err(e) => {
                self.handle_run_start_failure(
                    notification_handler,
                    conn,
                    Some(test_id),
                    Some(run_group.run_group_id),
                    &format!("Failed to start first (head) run due to: {}", e),
                )
                .await;
                return;
            }
        };
        // Start run for base
        let base_run = match util::start_run_from_request(
            conn,
            test_runner,
            test_id,
            Some(run_group.run_group_id),
            self.test_input_key.as_deref(),
            self.eval_input_key.as_deref(),
            &self.software_name,
            &self.base_commit,
        )
        .await
        {
            Ok(run) => run,
            Err(e) => {
                // Note: we don't include the run group for deletion here because the head run was
                // created successfully and references it
                self.handle_run_start_failure(
                    notification_handler,
                    conn,
                    Some(test_id),
                    None,
                    &format!("Failed to start second (base) run due to: {}\nHead run started with id: {}", e, head_run.run_id)
                ).await;
                return;
            }
        };
        // Write github info to the db
        match self.record_github_info(conn, run_group.run_group_id) {
            Ok(_) => debug!(
                "Created run_group_is_from_github record for run group {}",
                run_group.run_group_id
            ),
            Err(e) => {
                error!("Encountered an error trying to create a run_group_is_from_github record for run_group {}: {}", run_group.run_group_id, e);
                self.handle_run_start_failure(
                    notification_handler,
                    conn,
                    Some(test_id),
                    None,
                    &format!("Runs started with run_group_id {} but failed to register github info due to error: {}\nRetrieving info about this run will need to be done through carrot_cli.", run_group.run_group_id, e)
                ).await;
                return;
            }
        }
        // Send notifications
        if let Err(e) = notification_handler
            .send_pr_run_started_from_github_notifications(
                conn,
                &self.owner,
                &self.repo,
                &self.author,
                self.issue_number,
                &base_run,
                &head_run,
                &self.test_name,
            )
            .await
        {
            error!(
                "Failed to send PR run start notifications due to the following error: {}",
                e
            );
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::config::{EmailConfig, EmailSendmailConfig};
    use crate::custom_sql_types::{
        BuildStatusEnum, EntityTypeEnum, MachineTypeEnum, RunStatusEnum,
    };
    use crate::manager::github::{GithubPrRequest, GithubRunRequest, GithubRunner};
    use crate::manager::notification_handler::NotificationHandler;
    use crate::manager::test_runner::TestRunner;
    use crate::models::pipeline::{NewPipeline, PipelineData};
    use crate::models::run::{RunData, RunQuery};
    use crate::models::run_is_from_github::RunIsFromGithubData;
    use crate::models::run_software_version::RunSoftwareVersionData;
    use crate::models::software::{NewSoftware, SoftwareData};
    use crate::models::software_build::{SoftwareBuildData, SoftwareBuildQuery};
    use crate::models::software_version::{SoftwareVersionData, SoftwareVersionQuery};
    use crate::models::subscription::{NewSubscription, SubscriptionData};
    use crate::models::template::{NewTemplate, TemplateData};
    use crate::models::test::{NewTest, TestData};
    use crate::notifications::emailer::Emailer;
    use crate::notifications::github_commenter::GithubCommenter;
    use crate::requests::cromwell_requests::CromwellClient;
    use crate::requests::github_requests::GithubClient;
    use crate::requests::test_resource_requests::TestResourceClient;
    use crate::unit_test_util::{
        get_test_db_connection, get_test_remote_github_repo, get_test_test_runner_building_enabled,
        insert_test_software_with_repo,
    };
    use actix_web::client::Client;
    use diesel::PgConnection;
    use mailparse::MailHeaderMap;
    use serde::Deserialize;
    use serde_json::{json, Value};
    use std::env::temp_dir;
    use std::fs::{read_dir, read_to_string, DirEntry};
    use uuid::Uuid;

    #[derive(Deserialize)]
    struct ParsedEmailFile {
        envelope: Value,
        #[serde(with = "serde_bytes")]
        message: Vec<u8>,
    }

    fn insert_test_test_with_subscriptions_with_entities(
        conn: &PgConnection,
        email_base_name: &str,
    ) -> TestData {
        let pipeline = insert_test_pipeline(conn);
        let template = insert_test_template_with_pipeline_id(conn, pipeline.pipeline_id);
        let test = insert_test_test_with_template_id(conn, template.template_id);

        let new_subscription = NewSubscription {
            entity_type: EntityTypeEnum::Pipeline,
            entity_id: pipeline.pipeline_id,
            email: String::from(format!("{}@example.com", email_base_name)),
        };

        SubscriptionData::create(conn, new_subscription)
            .expect("Failed inserting test subscription");

        let new_subscription = NewSubscription {
            entity_type: EntityTypeEnum::Template,
            entity_id: template.template_id,
            email: String::from(format!("{}@example.com", email_base_name)),
        };

        SubscriptionData::create(conn, new_subscription)
            .expect("Failed inserting test subscription");

        let new_subscription = NewSubscription {
            entity_type: EntityTypeEnum::Test,
            entity_id: test.test_id,
            email: String::from(format!("{}@example.com", email_base_name)),
        };
        SubscriptionData::create(conn, new_subscription)
            .expect("Failed inserting test subscription");

        test
    }

    fn insert_test_pipeline(conn: &PgConnection) -> PipelineData {
        let new_pipeline = NewPipeline {
            name: String::from("Kevin's Pipeline"),
            description: Some(String::from("Kevin made this pipeline for testing")),
            created_by: Some(String::from("Kevin@example.com")),
        };

        PipelineData::create(conn, new_pipeline).expect("Failed inserting test pipeline")
    }

    fn insert_test_template_with_pipeline_id(conn: &PgConnection, id: Uuid) -> TemplateData {
        let new_template = NewTemplate {
            name: String::from("Kevin's test template"),
            pipeline_id: id,
            description: None,
            test_wdl: format!("{}/test_software_params", mockito::server_url()),
            test_wdl_dependencies: None,
            eval_wdl: format!("{}/eval_software_params", mockito::server_url()),
            eval_wdl_dependencies: None,
            created_by: None,
        };

        TemplateData::create(&conn, new_template).expect("Failed to insert test")
    }

    fn insert_test_test_with_template_id(conn: &PgConnection, id: Uuid) -> TestData {
        let new_test = NewTest {
            name: String::from("Kevin's test test"),
            template_id: id,
            description: None,
            test_input_defaults: None,
            test_option_defaults: None,
            eval_input_defaults: None,
            eval_option_defaults: None,
            created_by: None,
        };

        TestData::create(&conn, new_test).expect("Failed to insert test")
    }

    fn create_test_notification_handler() -> NotificationHandler {
        // Create an emailer
        let test_email_config =
            EmailConfig::Sendmail(EmailSendmailConfig::new(String::from("kevin@example.com")));
        let test_emailer = Emailer::new(test_email_config);
        // Get client
        let client = Client::default();
        // Create a github client
        let github_client = GithubClient::new("user", "aaaaaaaaaaaaaaaaaaaaaa", client);
        // Create a github commenter
        let github_commenter = GithubCommenter::new(github_client);
        // Create a notification handler
        NotificationHandler::new(
            Some(test_emailer),
            Some(github_commenter),
            String::from("example.com"),
        )
    }

    fn assert_run_mapped_to_software_with_commit(
        conn: &PgConnection,
        run_id: Uuid,
        commit: &str,
        software_id: Uuid,
    ) {
        let software_version_q = SoftwareVersionQuery {
            software_version_id: None,
            software_id: Some(software_id),
            commit: Some(String::from(commit)),
            software_name: None,
            created_before: None,
            created_after: None,
            committed_before: None,
            committed_after: None,
            sort: None,
            limit: None,
            offset: None,
        };
        let created_software_version =
            SoftwareVersionData::find(&conn, software_version_q).unwrap();
        assert_eq!(created_software_version.len(), 1);

        let software_build_q = SoftwareBuildQuery {
            software_build_id: None,
            software_version_id: Some(created_software_version[0].software_version_id),
            build_job_id: None,
            status: Some(BuildStatusEnum::Created),
            image_url: None,
            created_before: None,
            created_after: None,
            finished_before: None,
            finished_after: None,
            sort: None,
            limit: None,
            offset: None,
        };
        let created_software_build = SoftwareBuildData::find(&conn, software_build_q).unwrap();
        assert_eq!(created_software_build.len(), 1);

        let created_run_software_version =
            RunSoftwareVersionData::find_by_run_and_software_version(
                &conn,
                run_id,
                created_software_version[0].software_version_id,
            )
            .unwrap();
    }

    #[actix_rt::test]
    async fn test_process_success() {
        let logger = simple_logger::SimpleLogger::new();
        let conn = get_test_db_connection();
        let test_test_runner = get_test_test_runner_building_enabled();
        let test_notification_handler = create_test_notification_handler();

        let test_test = insert_test_test_with_subscriptions_with_entities(
            &conn,
            "test_process_pr_request_success",
        );

        let (test_repo, commit1, commit2, _, _) = get_test_remote_github_repo();
        let test_software = insert_test_software_with_repo(&conn, test_repo.to_str().unwrap());

        let test_request = GithubPrRequest {
            test_name: test_test.name,
            test_input_key: Some(String::from("in_test_image")),
            eval_input_key: Some(String::from("in_eval_image")),
            software_name: test_software.name,
            base_commit: commit1.clone(),
            head_commit: commit2.clone(),
            owner: String::from("TestOwner"),
            repo: String::from("TestRepo"),
            issue_number: 4,
            author: String::from("ExampleKevin"),
        };

        // Define mockito mapping for github comment response
        let mock = mockito::mock("POST", "/repos/TestOwner/TestRepo/issues/4/comments")
            .match_header("Accept", "application/vnd.github.v3+json")
            .with_status(201)
            .create();

        let base_test_params =
            json!({ "in_test_image": format!("image_build:TestSoftware|{}", &commit1) });
        let base_eval_params =
            json!({ "in_eval_image": format!("image_build:TestSoftware|{}", &commit1) });
        let head_test_params =
            json!({ "in_test_image": format!("image_build:TestSoftware|{}", &commit2) });
        let head_eval_params =
            json!({ "in_eval_image": format!("image_build:TestSoftware|{}", &commit2) });

        // Make temporary directory for the email
        let email_path = tempfile::Builder::new()
            .prefix("test_process_pr_request_success")
            .rand_bytes(0)
            .tempdir_in(temp_dir())
            .unwrap();

        test_request
            .process(&test_test_runner, &test_notification_handler, &conn)
            .await;

        // Verify that the email was created correctly
        let files_in_dir = read_dir(email_path.path())
            .unwrap()
            .collect::<Vec<std::io::Result<DirEntry>>>();

        assert_eq!(files_in_dir.len(), 1);

        let test_email_string =
            read_to_string(files_in_dir.get(0).unwrap().as_ref().unwrap().path()).unwrap();
        let test_email: ParsedEmailFile = serde_json::from_str(&test_email_string).unwrap();

        assert_eq!(
            test_email
                .envelope
                .get("forward_path")
                .unwrap()
                .as_array()
                .unwrap()
                .get(0)
                .unwrap(),
            "test_process_pr_request_success@example.com"
        );
        assert_eq!(
            test_email.envelope.get("reverse_path").unwrap(),
            "kevin@example.com"
        );

        let parsed_mail = mailparse::parse_mail(&test_email.message).unwrap();

        let message = String::from(parsed_mail.subparts[0].get_body().unwrap().trim());
        let subject = parsed_mail.headers.get_first_value("Subject").unwrap();
        assert_eq!(subject, "Successfully started run from GitHub");
        let split_message: Vec<&str> = message.splitn(2, "\n").collect();
        assert_eq!(
            split_message[0],
            "GitHub user ExampleKevin started a PR run for test Kevin's test test:"
        );
        // Get the runs that were created
        let mut test_runs = RunData::find(
            &conn,
            RunQuery {
                pipeline_id: None,
                template_id: None,
                test_id: Some(test_test.test_id),
                run_group_id: None,
                name: None,
                status: None,
                test_input: None,
                test_options: None,
                eval_input: None,
                eval_options: None,
                test_cromwell_job_id: None,
                eval_cromwell_job_id: None,
                software_versions: None,
                created_before: None,
                created_after: None,
                created_by: None,
                finished_before: None,
                finished_after: None,
                sort: None,
                limit: None,
                offset: None,
            },
        )
        .unwrap();

        assert_eq!(test_runs[0].test_id, test_test.test_id);
        assert_eq!(test_runs[0].status, RunStatusEnum::Building);
        assert_eq!(test_runs[1].test_id, test_test.test_id);
        assert_eq!(test_runs[1].status, RunStatusEnum::Building);

        assert_eq!(test_runs.len(), 2);

        let (base_run, head_run) = {
            if test_runs[0].test_input == base_test_params {
                let head_run = test_runs.pop().unwrap();
                let base_run = test_runs.pop().unwrap();
                (base_run, head_run)
            } else {
                let base_run = test_runs.pop().unwrap();
                let head_run = test_runs.pop().unwrap();
                (base_run, head_run)
            }
        };

        assert_eq!(base_run.test_input, base_test_params);
        assert_eq!(base_run.eval_input, base_eval_params);
        assert_eq!(head_run.test_input, head_test_params);
        assert_eq!(head_run.eval_input, head_eval_params);

        assert_run_mapped_to_software_with_commit(
            &conn,
            base_run.run_id,
            &commit1,
            test_software.software_id,
        );
        assert_run_mapped_to_software_with_commit(
            &conn,
            head_run.run_id,
            &commit2,
            test_software.software_id,
        );

        mock.assert();

        email_path.close().unwrap();
    }

    #[actix_rt::test]
    async fn test_process_failure_no_software() {
        let conn = get_test_db_connection();
        let test_test_runner = get_test_test_runner_building_enabled();
        let test_notification_handler = create_test_notification_handler();
        let test_test = insert_test_test_with_subscriptions_with_entities(
            &conn,
            "test_process_request_failure_no_software",
        );

        let test_request = GithubPrRequest {
            test_name: test_test.name,
            test_input_key: Some(String::from("in_test_image")),
            eval_input_key: Some(String::from("in_eval_image")),
            software_name: String::from("TestSoftware"),
            base_commit: String::from("764a00442ddb412eed331655cfd90e151f580518"),
            head_commit: String::from("af9cbceb8388e2170881d17f5ca88833c5c37ed6"),
            owner: String::from("TestOwner"),
            repo: String::from("TestRepo"),
            issue_number: 4,
            author: String::from("ExampleKevin"),
        };

        // Define mockito mapping for github comment response
        let mock = mockito::mock("POST", "/repos/TestOwner/TestRepo/issues/4/comments")
            .match_header("Accept", "application/vnd.github.v3+json")
            .with_status(201)
            .create();

        // Make temporary directory for the email
        let email_path = tempfile::Builder::new()
            .prefix("test_process_request_failure_no_software")
            .rand_bytes(0)
            .tempdir_in(temp_dir())
            .unwrap();

        test_request
            .process(&test_test_runner, &test_notification_handler, &conn)
            .await;

        // Verify that the email was created correctly
        let files_in_dir = read_dir(email_path.path())
            .unwrap()
            .collect::<Vec<std::io::Result<DirEntry>>>();

        assert_eq!(files_in_dir.len(), 1);

        let test_email_string =
            read_to_string(files_in_dir.get(0).unwrap().as_ref().unwrap().path()).unwrap();
        let test_email: ParsedEmailFile = serde_json::from_str(&test_email_string).unwrap();

        assert_eq!(
            test_email
                .envelope
                .get("forward_path")
                .unwrap()
                .as_array()
                .unwrap()
                .get(0)
                .unwrap(),
            "test_process_request_failure_no_software@example.com"
        );
        assert_eq!(
            test_email.envelope.get("reverse_path").unwrap(),
            "kevin@example.com"
        );

        let parsed_mail = mailparse::parse_mail(&test_email.message).unwrap();

        let message = String::from(parsed_mail.subparts[0].get_body().unwrap().trim());
        let subject = parsed_mail.headers.get_first_value("Subject").unwrap();
        assert_eq!(
            subject,
            "Encountered an error when attempting to start a pr comparison test run from GitHub"
        );
        assert_eq!(message, "GitHub user ExampleKevin attempted to start a pr comparison run for test Kevin's test test, but encountered the following error: Failed to start first (head) run due to: Error Run Error SoftwareNotFound: TestSoftware");

        mock.assert();

        email_path.close().unwrap();
    }

    #[test]
    fn test_from_json_success() {
        let test_json = json!({
            "test_name": "test name",
            "test_input_key": "in_test_image",
            "eval_input_key": "",
            "software_name": "cool_software",
            "base_commit": "764a00442ddb412eed331655cfd90e151f580518",
            "head_commit": "af9cbceb8388e2170881d17f5ca88833c5c37ed6",
            "owner":"TestOwner",
            "repo":"TestRepo",
            "issue_number":4,
            "author": "ExampleKevin"
        });

        let request = GithubPrRequest::from_json(&test_json).unwrap();

        assert_eq!(
            request,
            GithubPrRequest {
                test_name: "test name".to_string(),
                test_input_key: Some(String::from("in_test_image")),
                eval_input_key: None,
                software_name: "cool_software".to_string(),
                base_commit: "764a00442ddb412eed331655cfd90e151f580518".to_string(),
                head_commit: "af9cbceb8388e2170881d17f5ca88833c5c37ed6".to_string(),
                owner: "TestOwner".to_string(),
                repo: "TestRepo".to_string(),
                issue_number: 4,
                author: "ExampleKevin".to_string()
            }
        )
    }

    #[test]
    fn test_from_json_failure() {
        let test_json = json!({
            "test_name": "test name",
            "test_input_key": "in_test_image",
            "eval_input_key": "",
            "software_name": "cool_software",
            "commit": "764a00442ddb412eed331655cfd90e151f580518",
            "owner":"TestOwner",
            "repo":"TestRepo",
            "issue_number":4,
            "blah": "ExampleKevin"
        });

        GithubPrRequest::from_json(&test_json).unwrap_err();
    }
}
