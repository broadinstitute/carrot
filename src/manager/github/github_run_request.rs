//! Defines a struct for handling requests from github to start a run

use super::util;
use crate::manager::notification_handler::NotificationHandler;
use crate::manager::test_runner::TestRunner;
use crate::models::run_is_from_github::{NewRunIsFromGithub, RunIsFromGithubData};
use crate::models::test::TestData;
use diesel::PgConnection;
use log::{debug, error};
use serde::Deserialize;
use serde_json::Value;
use uuid::Uuid;

/// Represents the data received from a GitHub Actions request to start a test run
///
/// `test_input_key` and `eval_input_key` each respectively refer to the key in the test_input and
/// eval_input for the test that should be filled with a build generated by CARROT using the
/// specified `software_name` and `commit`.  `author` refers to the Github username of the person
/// who triggered the request in GitHub by creating a comment in the format to trigger a test run
#[derive(Debug, Deserialize, Eq, PartialEq)]
pub struct GithubRunRequest {
    pub test_name: String,
    pub test_input_key: Option<String>,
    pub eval_input_key: Option<String>,
    pub software_name: String,
    pub commit: String,
    pub owner: String,
    pub repo: String,
    pub issue_number: i32,
    pub author: String,
}

impl GithubRunRequest {
    /// Attempts to create a GithubRunRequest from `obj` by deserializing and updates input keys to
    /// be None if they have been provided as empty strings
    pub fn from_json(obj: &Value) -> Result<Self, serde_json::Error> {
        // Parse as a GithubRunRequest
        let mut request: GithubRunRequest = serde_json::from_value(obj.clone())?;
        // If either of the input keys for docker images is an empty string, set it to null
        match &request.test_input_key {
            Some(key) => {
                if key.is_empty() {
                    request.test_input_key = None;
                }
            }
            None => {}
        }
        match &request.eval_input_key {
            Some(key) => {
                if key.is_empty() {
                    request.eval_input_key = None;
                }
            }
            None => {}
        }

        Ok(request)
    }

    /// Creates a record in the RUN_IS_FROM_GITHUB table to store the data (`owner`, `repo`,
    /// `issue_number`, `author`) related to the github comment that triggered the run (`run_id`)
    fn record_github_info(
        &self,
        conn: &PgConnection,
        run_id: Uuid,
    ) -> Result<RunIsFromGithubData, diesel::result::Error> {
        let github_info_rec = NewRunIsFromGithub {
            run_id,
            owner: self.owner.clone(),
            repo: self.repo.clone(),
            issue_number: self.issue_number,
            author: self.author.clone(),
        };

        RunIsFromGithubData::create(conn, github_info_rec)
    }

    /// Starts a run (using `test_runner`), which will build an image for `self.commit` and pass it
    /// in to `self.test_input_key` and `self.eval_input_key` if provided. Then sends notifications
    /// to indicate the run has started successfully, or containing error messages if anything goes
    /// wrong
    pub async fn process(
        &self,
        test_runner: &TestRunner,
        notification_handler: &NotificationHandler,
        conn: &PgConnection,
    ) {
        // First, retrieve the test id for the test name
        let test_id = match TestData::find_id_by_name(conn, &self.test_name) {
            Ok(id) => id,
            Err(e) => {
                let error_message = format!("Failed to start run from GitHub with test_name: {} due to error when trying to retrieve test_id: {}", &self.test_name, e);
                if let Err(e) = notification_handler
                    .send_run_failed_to_start_from_github_notifications(
                        conn,
                        &self.owner,
                        &self.repo,
                        &self.author,
                        self.issue_number,
                        &self.test_name,
                        None,
                        &error_message,
                    )
                    .await
                {
                    error!("Failed to send notifications for run failed to start error due to error: {}", e);
                }
                return;
            }
        };
        // Start run
        match util::start_run_from_request(
            conn,
            test_runner,
            test_id,
            None,
            self.test_input_key.as_deref(),
            self.eval_input_key.as_deref(),
            &self.software_name,
            &self.commit,
        )
        .await
        {
            Ok(run) => {
                // Insert run_is_from_github record for the created run
                match self.record_github_info(conn, run.run_id) {
                    Ok(_) => debug!("Created run_is_from_github record for run {}", run.run_id),
                    Err(e) => error!("Encountered an error trying to create a run_is_from_github record for run {}: {}", run.run_id, e)
                }
                // Send notifications
                if let Err(e) = notification_handler
                    .send_run_started_from_github_notifications(
                        conn,
                        &self.owner,
                        &self.repo,
                        &self.author,
                        self.issue_number,
                        &run,
                        &self.test_name,
                    )
                    .await
                {
                    error!(
                        "Failed to send run start notifications due to the following error: {}",
                        e
                    );
                }
            }
            Err(e) => {
                error!(
                    "Encountered an error when trying to start a run from GitHub: {}",
                    e
                );
                // Send notifications for failure
                if let Err(e) = notification_handler
                    .send_run_failed_to_start_from_github_notifications(
                        conn,
                        &self.owner,
                        &self.repo,
                        &self.author,
                        self.issue_number,
                        &self.test_name,
                        Some(test_id),
                        &e.to_string(),
                    )
                    .await
                {
                    error!("Failed to send run start failure notifications due to the following error: {}", e);
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use crate::config::{EmailConfig, EmailSendmailConfig};
    use crate::custom_sql_types::{
        BuildStatusEnum, EntityTypeEnum, MachineTypeEnum, RunStatusEnum,
    };
    use crate::manager::github::{GithubRunRequest, GithubRunner};
    use crate::manager::notification_handler::NotificationHandler;
    use crate::manager::test_runner::TestRunner;
    use crate::models::pipeline::{NewPipeline, PipelineData};
    use crate::models::run::RunData;
    use crate::models::run_is_from_github::RunIsFromGithubData;
    use crate::models::run_software_version::RunSoftwareVersionData;
    use crate::models::software::{NewSoftware, SoftwareData};
    use crate::models::software_build::{SoftwareBuildData, SoftwareBuildQuery};
    use crate::models::software_version::{SoftwareVersionData, SoftwareVersionQuery};
    use crate::models::subscription::{NewSubscription, SubscriptionData};
    use crate::models::template::{NewTemplate, TemplateData};
    use crate::models::test::{NewTest, TestData};
    use crate::notifications::emailer::Emailer;
    use crate::notifications::github_commenter::GithubCommenter;
    use crate::requests::cromwell_requests::CromwellClient;
    use crate::requests::github_requests::GithubClient;
    use crate::requests::test_resource_requests::TestResourceClient;
    use crate::unit_test_util::{
        get_test_db_connection, get_test_remote_github_repo, get_test_test_runner_building_enabled,
        insert_test_software_with_repo,
    };
    use actix_web::client::Client;
    use diesel::PgConnection;
    use mailparse::MailHeaderMap;
    use serde::Deserialize;
    use serde_json::{json, Value};
    use std::env::temp_dir;
    use std::fs::{read_dir, read_to_string, DirEntry};
    use uuid::Uuid;

    #[derive(Deserialize)]
    struct ParsedEmailFile {
        envelope: Value,
        #[serde(with = "serde_bytes")]
        message: Vec<u8>,
    }

    fn insert_test_test_with_subscriptions_with_entities(
        conn: &PgConnection,
        email_base_name: &str,
    ) -> TestData {
        let pipeline = insert_test_pipeline(conn);
        let template = insert_test_template_with_pipeline_id(conn, pipeline.pipeline_id);
        let test = insert_test_test_with_template_id(conn, template.template_id);

        let new_subscription = NewSubscription {
            entity_type: EntityTypeEnum::Pipeline,
            entity_id: pipeline.pipeline_id,
            email: String::from(format!("{}@example.com", email_base_name)),
        };

        SubscriptionData::create(conn, new_subscription)
            .expect("Failed inserting test subscription");

        let new_subscription = NewSubscription {
            entity_type: EntityTypeEnum::Template,
            entity_id: template.template_id,
            email: String::from(format!("{}@example.com", email_base_name)),
        };

        SubscriptionData::create(conn, new_subscription)
            .expect("Failed inserting test subscription");

        let new_subscription = NewSubscription {
            entity_type: EntityTypeEnum::Test,
            entity_id: test.test_id,
            email: String::from(format!("{}@example.com", email_base_name)),
        };
        SubscriptionData::create(conn, new_subscription)
            .expect("Failed inserting test subscription");

        test
    }

    fn insert_test_pipeline(conn: &PgConnection) -> PipelineData {
        let new_pipeline = NewPipeline {
            name: String::from("Kevin's Pipeline"),
            description: Some(String::from("Kevin made this pipeline for testing")),
            created_by: Some(String::from("Kevin@example.com")),
        };

        PipelineData::create(conn, new_pipeline).expect("Failed inserting test pipeline")
    }

    fn insert_test_template_with_pipeline_id(conn: &PgConnection, id: Uuid) -> TemplateData {
        let new_template = NewTemplate {
            name: String::from("Kevin's test template"),
            pipeline_id: id,
            description: None,
            test_wdl: format!("{}/test_software_params", mockito::server_url()),
            test_wdl_dependencies: None,
            eval_wdl: format!("{}/eval_software_params", mockito::server_url()),
            eval_wdl_dependencies: None,
            created_by: None,
        };

        TemplateData::create(&conn, new_template).expect("Failed to insert test")
    }

    fn insert_test_test_with_template_id(conn: &PgConnection, id: Uuid) -> TestData {
        let new_test = NewTest {
            name: String::from("Kevin's test test"),
            template_id: id,
            description: None,
            test_input_defaults: None,
            test_option_defaults: None,
            eval_input_defaults: None,
            eval_option_defaults: None,
            created_by: None,
        };

        TestData::create(&conn, new_test).expect("Failed to insert test")
    }

    fn create_test_notification_handler() -> NotificationHandler {
        // Create an emailer
        let test_email_config =
            EmailConfig::Sendmail(EmailSendmailConfig::new(String::from("kevin@example.com")));
        let test_emailer = Emailer::new(test_email_config);
        // Get client
        let client = Client::default();
        // Create a github client
        let github_client = GithubClient::new("user", "aaaaaaaaaaaaaaaaaaaaaa", client);
        // Create a github commenter
        let github_commenter = GithubCommenter::new(github_client);
        // Create a notification handler
        NotificationHandler::new(
            Some(test_emailer),
            Some(github_commenter),
            String::from("example.com"),
        )
    }

    #[actix_rt::test]
    async fn test_process_success() {
        let conn = get_test_db_connection();
        let test_test_runner = get_test_test_runner_building_enabled();
        let test_notification_handler = create_test_notification_handler();

        let test_test = insert_test_test_with_subscriptions_with_entities(
            &conn,
            "test_process_request_success",
        );

        let (test_repo, commit1, _, _, _) = get_test_remote_github_repo();
        let test_software = insert_test_software_with_repo(&conn, test_repo.to_str().unwrap());

        let test_request = GithubRunRequest {
            test_name: test_test.name,
            test_input_key: Some(String::from("in_test_image")),
            eval_input_key: Some(String::from("in_eval_image")),
            software_name: test_software.name,
            commit: commit1.clone(),
            owner: String::from("ExampleOwner"),
            repo: String::from("ExampleRepo"),
            issue_number: 4,
            author: String::from("ExampleKevin"),
        };

        // Define mockito mapping for github comment response
        let mock = mockito::mock("POST", "/repos/ExampleOwner/ExampleRepo/issues/4/comments")
            .match_header("Accept", "application/vnd.github.v3+json")
            .with_status(201)
            .create();

        let test_params =
            json!({ "in_test_image": format!("image_build:TestSoftware|{}", &commit1) });
        let eval_params =
            json!({ "in_eval_image": format!("image_build:TestSoftware|{}", &commit1) });

        // Make temporary directory for the email
        let email_path = tempfile::Builder::new()
            .prefix("test_process_request_success")
            .rand_bytes(0)
            .tempdir_in(temp_dir())
            .unwrap();

        test_request
            .process(&test_test_runner, &test_notification_handler, &conn)
            .await;

        // Verify that the email was created correctly
        let files_in_dir = read_dir(email_path.path())
            .unwrap()
            .collect::<Vec<std::io::Result<DirEntry>>>();

        assert_eq!(files_in_dir.len(), 1);

        let test_email_string =
            read_to_string(files_in_dir.get(0).unwrap().as_ref().unwrap().path()).unwrap();
        let test_email: ParsedEmailFile = serde_json::from_str(&test_email_string).unwrap();

        assert_eq!(
            test_email
                .envelope
                .get("forward_path")
                .unwrap()
                .as_array()
                .unwrap()
                .get(0)
                .unwrap(),
            "test_process_request_success@example.com"
        );
        assert_eq!(
            test_email.envelope.get("reverse_path").unwrap(),
            "kevin@example.com"
        );

        let parsed_mail = mailparse::parse_mail(&test_email.message).unwrap();

        let message = String::from(parsed_mail.subparts[0].get_body().unwrap().trim());
        let subject = parsed_mail.headers.get_first_value("Subject").unwrap();
        assert_eq!(subject, "Successfully started run from GitHub");
        let split_message: Vec<&str> = message.splitn(2, "\n").collect();
        assert_eq!(
            split_message[0],
            "GitHub user ExampleKevin started a run for test Kevin's test test:"
        );
        let test_run: RunData = serde_json::from_str(split_message[1].trim()).unwrap();

        assert_eq!(test_run.test_id, test_test.test_id);
        assert_eq!(test_run.status, RunStatusEnum::Building);
        assert_eq!(test_run.test_input, test_params);
        assert_eq!(test_run.eval_input, eval_params);

        let software_version_q = SoftwareVersionQuery {
            software_version_id: None,
            software_id: Some(test_software.software_id),
            commit: Some(commit1),
            software_name: None,
            created_before: None,
            created_after: None,
            committed_before: None,
            committed_after: None,
            sort: None,
            limit: None,
            offset: None,
        };
        let created_software_version =
            SoftwareVersionData::find(&conn, software_version_q).unwrap();
        assert_eq!(created_software_version.len(), 1);

        let software_build_q = SoftwareBuildQuery {
            software_build_id: None,
            software_version_id: Some(created_software_version[0].software_version_id),
            build_job_id: None,
            status: Some(BuildStatusEnum::Created),
            image_url: None,
            created_before: None,
            created_after: None,
            finished_before: None,
            finished_after: None,
            sort: None,
            limit: None,
            offset: None,
        };
        let created_software_build = SoftwareBuildData::find(&conn, software_build_q).unwrap();
        assert_eq!(created_software_build.len(), 1);

        let created_run_software_version =
            RunSoftwareVersionData::find_by_run_and_software_version(
                &conn,
                test_run.run_id,
                created_software_version[0].software_version_id,
            )
            .unwrap();

        let created_run_is_from_github =
            RunIsFromGithubData::find_by_run_id(&conn, test_run.run_id).unwrap();
        assert_eq!(created_run_is_from_github.issue_number, 4);
        assert_eq!(created_run_is_from_github.owner, "ExampleOwner");
        assert_eq!(created_run_is_from_github.repo, "ExampleRepo");
        assert_eq!(created_run_is_from_github.author, "ExampleKevin");

        mock.assert();

        email_path.close().unwrap();
    }

    #[actix_rt::test]
    async fn test_process_failure_no_software() {
        let conn = get_test_db_connection();
        let test_test_runner = get_test_test_runner_building_enabled();
        let test_notification_handler = create_test_notification_handler();
        let test_test = insert_test_test_with_subscriptions_with_entities(
            &conn,
            "test_process_request_failure_no_software",
        );

        let test_request = GithubRunRequest {
            test_name: test_test.name,
            test_input_key: Some(String::from("in_test_image")),
            eval_input_key: Some(String::from("in_eval_image")),
            software_name: String::from("TestSoftware"),
            commit: String::from("764a00442ddb412eed331655cfd90e151f580518"),
            owner: String::from("ExampleOwner"),
            repo: String::from("ExampleRepo"),
            issue_number: 4,
            author: String::from("ExampleKevin"),
        };

        // Define mockito mapping for github comment response
        let mock = mockito::mock("POST", "/repos/ExampleOwner/ExampleRepo/issues/4/comments")
            .match_header("Accept", "application/vnd.github.v3+json")
            .with_status(201)
            .create();

        // Make temporary directory for the email
        let email_path = tempfile::Builder::new()
            .prefix("test_process_request_failure_no_software")
            .rand_bytes(0)
            .tempdir_in(temp_dir())
            .unwrap();

        test_request
            .process(&test_test_runner, &test_notification_handler, &conn)
            .await;

        // Verify that the email was created correctly
        let files_in_dir = read_dir(email_path.path())
            .unwrap()
            .collect::<Vec<std::io::Result<DirEntry>>>();

        assert_eq!(files_in_dir.len(), 1);

        let test_email_string =
            read_to_string(files_in_dir.get(0).unwrap().as_ref().unwrap().path()).unwrap();
        let test_email: ParsedEmailFile = serde_json::from_str(&test_email_string).unwrap();

        assert_eq!(
            test_email
                .envelope
                .get("forward_path")
                .unwrap()
                .as_array()
                .unwrap()
                .get(0)
                .unwrap(),
            "test_process_request_failure_no_software@example.com"
        );
        assert_eq!(
            test_email.envelope.get("reverse_path").unwrap(),
            "kevin@example.com"
        );

        let parsed_mail = mailparse::parse_mail(&test_email.message).unwrap();

        let message = String::from(parsed_mail.subparts[0].get_body().unwrap().trim());
        let subject = parsed_mail.headers.get_first_value("Subject").unwrap();
        assert_eq!(
            subject,
            "Encountered an error when attempting to start a test run from GitHub"
        );
        assert_eq!(message, "GitHub user ExampleKevin attempted to start a run for test Kevin's test test, but encountered the following error: Error Run Error SoftwareNotFound: TestSoftware");

        mock.assert();

        email_path.close().unwrap();
    }

    #[test]
    fn test_from_json_success() {
        let test_json = json!({
            "test_name": "test name",
            "test_input_key": "in_test_image",
            "eval_input_key": "",
            "software_name": "cool_software",
            "commit": "764a00442ddb412eed331655cfd90e151f580518",
            "owner":"TestOwner",
            "repo":"TestRepo",
            "issue_number":4,
            "author": "ExampleKevin"
        });

        let request = GithubRunRequest::from_json(&test_json).unwrap();

        assert_eq!(
            request,
            GithubRunRequest {
                test_name: "test name".to_string(),
                test_input_key: Some(String::from("in_test_image")),
                eval_input_key: None,
                software_name: "cool_software".to_string(),
                commit: "764a00442ddb412eed331655cfd90e151f580518".to_string(),
                owner: "TestOwner".to_string(),
                repo: "TestRepo".to_string(),
                issue_number: 4,
                author: "ExampleKevin".to_string()
            }
        )
    }

    #[test]
    fn test_from_json_failure() {
        let test_json = json!({
            "test_name": "test name",
            "test_input_key": "in_test_image",
            "eval_input_key": "",
            "software_name": "cool_software",
            "commit": "764a00442ddb412eed331655cfd90e151f580518",
            "owner":"TestOwner",
            "repo":"TestRepo",
            "issue_number":4,
            "blah": "ExampleKevin"
        });

        GithubRunRequest::from_json(&test_json).unwrap_err();
    }
}
